<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<NDepend IsCProject="true" IsPhysical="false" AppName="cppdependtest" Platform="DotNet" FileWrittenByProductVersion="2020.1.0.35">
  <OutputDir KeepXmlFiles="False">C:\Users\PTSD\Documents\Atmel Studio\7.0\WINC3400_PROVISION_AP_WITH_BLE_ON_CHIP_PROFILE1\WINC3400_PROVISION_AP_WITH_BLE_ON_CHIP_PROFILE1\src\CppDependOut</OutputDir>
  <Projects />
  <FrameworkProjects />
  <Dirs />
  <ZipSourceFiles>True</ZipSourceFiles>
  <Report Kind="0" SectionsEnabled="110591" XslPath="" Flags="261120" />
  <BuildComparisonSetting ProjectMode="DontCompare" BuildMode="NDaysAgoAnalysisResult" ProjectFileToCompareWith="" BuildFileToCompareWith="" NDaysAgo="30" />
  <BaselineInUISetting ProjectMode="DontCompare" BuildMode="NDaysAgoAnalysisResult" ProjectFileToCompareWith="" BuildFileToCompareWith="" NDaysAgo="30" />
  <CoverageFiles CoverageDir="" UncoverableAttribute="" />
  <Plugins Plugin="true" Vera="false" Modernize="false" CLangArgs="-checks=*,-android-*,-boost-*,-google-*,-fuchsia-*,-mpi-*,-objc-*,-cppcoreguidelines-*,-bugprone-*">
    <LoadedPlugins />
  </Plugins>
  <ProjectParserSettings ParseIncludes="false" ParserKind="clang" QmakeFilePath="" TIPath="" ReneseasPath="" ArmPath="" ParserNbCores="0" ParserNbErrors="0" ParserTimeOut="10" />
  <TrendMetrics UseCustomLog="False" LogRecurrence="1" LogLabel="2" UseCustomDir="False" CustomDir="">
    <Chart Name="Lines of Code" ShowInReport="True">
      <Serie MetricName="# Lines of Code" MetricUnit="Loc" Color="#FF00BFFF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Lines of Code (NotMyCode)" MetricUnit="Loc" Color="#FFA9A9A9" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Lines of Comments" MetricUnit="Lines" Color="#FF008000" ChartType="Line" ScaleExp="0" />
    </Chart>
    <Chart Name="Rules Violated" ShowInReport="True">
      <Serie MetricName="# Rules" MetricUnit="Rules" Color="#FF66CDAA" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Rules Violated" MetricUnit="Rules" Color="#FFFF8C00" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Critical Rules Violated" MetricUnit="Rules" Color="#FFFF0000" ChartType="Area" ScaleExp="0" />
    </Chart>
    <Chart Name="Rules Violations" ShowInReport="True">
      <Serie MetricName="# Rules Violations" MetricUnit="Violations" Color="#FFFF8C00" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Critical Rules Violations" MetricUnit="Violations" Color="#FFFF0000" ChartType="Area" ScaleExp="0" />
    </Chart>
    <Chart Name="Max" ShowInReport="True">
      <Serie MetricName="Max Cyclomatic Complexity for Methods" MetricUnit="Paths" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max # Lines of Code for Methods (JustMyCode)" MetricUnit="LoC" Color="#FF0000FF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max Nesting Depth for Methods" MetricUnit="Scopes" Color="#FFFFD700" ChartType="Line" ScaleExp="0" />
    </Chart>
    <Chart Name="Average" ShowInReport="True">
      <Serie MetricName="Average Cyclomatic Complexity for Methods" MetricUnit="Paths" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average # Lines of Code for Methods" MetricUnit="LoC" Color="#FF0000FF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average Nesting Depth for Methods" MetricUnit="Scopes" Color="#FFFFD700" ChartType="Line" ScaleExp="0" />
    </Chart>
    <Chart Name="Third-Party Usage" ShowInReport="True">
      <Serie MetricName="# Third-Party Types Used" MetricUnit="Types" Color="#FF0000FF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Third-Party Methods Used" MetricUnit="Methods" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Third-Party Projects Used" MetricUnit="Projects" Color="#FF646464" ChartType="Line" ScaleExp="1" />
      <Serie MetricName="# Third-Party Fields Used" MetricUnit="Fields" Color="#FFFFD700" ChartType="Line" ScaleExp="1" />
    </Chart>
  </TrendMetrics>
  <HistoricAnalysisResult PersistRecurrence="1" UseCustomDir="False" CustomDir="" />
  <SourceFileRebasing FromPath="" ToPath="" />
  <PathVariables />
  <RuleFiles />
  <ProjectRules AreActive="True" />
  <ProjectDebtSettings DebtSettingsStorage="0" SettingsFilePath="">
    <DebtSettings>
      <DebtFactor>1</DebtFactor>
      <AnnualInterestFactor>1</AnnualInterestFactor>
      <DebtDefault>0</DebtDefault>
      <AnnualInterestDefault>0</AnnualInterestDefault>
      <DebtStringFormat>$ManDay$</DebtStringFormat>
      <MoneyPerManHour>50</MoneyPerManHour>
      <Currency>USD</Currency>
      <CurrencyLocation>After</CurrencyLocation>
      <EstimatedNumberOfManDayToDevelop1000LogicalLinesOfCode>18</EstimatedNumberOfManDayToDevelop1000LogicalLinesOfCode>
      <NumberOfWorkDayPerYear>240</NumberOfWorkDayPerYear>
      <NumberOfWorkHourPerDay>8</NumberOfWorkHourPerDay>
      <A2B_RatingThreshold>5</A2B_RatingThreshold>
      <B2C_RatingThreshold>10</B2C_RatingThreshold>
      <C2D_RatingThreshold>20</C2D_RatingThreshold>
      <D2E_RatingThreshold>50</D2E_RatingThreshold>
      <Info2Minor_SeverityThreshold>1200000000</Info2Minor_SeverityThreshold>
      <Minor2Major_SeverityThreshold>12000000000</Minor2Major_SeverityThreshold>
      <Major2Critical_SeverityThreshold>72000000000</Major2Critical_SeverityThreshold>
      <Critical2Blocker_SeverityThreshold>360000000000</Critical2Blocker_SeverityThreshold>
    </DebtSettings>
  </ProjectDebtSettings><Queries>
    <Group Name="Quality Gates" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Quality Gates Evolution</Name>
from qg in QualityGates
let qgBaseline = qg.OlderVersion()
let relyOnDiff = qgBaseline == null
let evolution = relyOnDiff ? (TrendIcon?)null : 
                // When a quality gate relies on diff between now and baseline
                // it is not executed against the baseline
                qg.ValueDiff() == 0d ?
                TrendIcon.Constant :
                (qg.ValueDiff() > 0 ? 
                  ( qg.MoreIsBad ?  TrendIcon.RedUp: TrendIcon.GreenUp) :
                  (!qg.MoreIsBad ?  TrendIcon.RedDown: TrendIcon.GreenDown))
select new { qg, 
   Evolution      =  evolution,

   BaselineStatus =  relyOnDiff? (QualityGateStatus?) null : qgBaseline.Status,
   Status         =  qg.Status,

   BaselineValue  =  relyOnDiff? (null) : qgBaseline.ValueString,
   Value          =  qg.ValueString, 
}
 
// <Description>
// Show quality gates evolution between baseline and now.
//
// When a quality gate relies on diff between now and baseline (like *New Debt since Baseline*)
// it is not executed against the baseline and as a consequence its evolution is not available.
//
// Double-click a quality gate for editing.
// </Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Percentage Code Coverage" Unit="%" />
failif value < 70%
warnif value < 80%
codeBase.PercentageCoverage

//<Description>
// Code coverage is a measure used to describe the degree to which the source code of a program 
// is tested by a particular test suite. A program with high code coverage, measured as a percentage, 
// has had more of its source code executed during testing which suggests it has a lower chance of 
// containing undetected software bugs compared to a program with low code coverage.
//
// Code coverage is certainly the most important quality code metric. But coverage is not enough
// the team needs to ensure that results are checked at test-time. These checks can be done both 
// in test code, and in application code through assertions. The important part is that a test
// must fail explicitely when a check gets unvalidated during the test execution.
//
// This quality gate define a warn threshold (70%) and a fail threshold (80%). These are 
// indicative thresholds and in practice the more the better. To achieve high coverage and 
// low risk, make sure that new and refactored classes gets 100% covered by tests and that
// the application and test code contains as many checks/assertions as possible.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Percentage Coverage on New Code" Unit="%" />
failif value < 70%
warnif value < 80%
let newMethods = Application.Methods.Where(m => m.WasAdded() && m.NbLinesOfCode > 0)
let locCovered = newMethods.Sum(m => m.NbLinesOfCodeCovered)
let loc = newMethods.Sum(m => m.NbLinesOfCode)
select 100d * locCovered / loc

//<Description>
// *New Code* is defined as methods added since the baseline.
//
// To achieve high code coverage it is essential that new code gets properly
// tested and covered by tests. It is advised that all non-UI new classes gets
// 100% covered.
//
// Typically 90% of a class is easy to cover by tests and 10% is hard to reach 
// through tests. It means that this 10% remaining is not easily testable, which 
// means it is not well designed, which often means that this code is especially 
// **error-prone**. This is the reason why it is important to reach 100% coverage
// for a class, to make sure that potentially *error-prone* code gets tested.
//</Description>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Percentage Coverage on Refactored Code" Unit="%" />
failif value < 70%
warnif value < 80%
let newMethods = Application.Methods.Where(m => m.CodeWasChanged() && m.NbLinesOfCode > 0)
let locCovered = newMethods.Sum(m => m.NbLinesOfCodeCovered)
let loc = newMethods.Sum(m => m.NbLinesOfCode)
select 100d * locCovered / loc

//<Description>
// *Refactored Code* is defined as methods where *code was changed* since the baseline.
//
// Comment changes and formatting changes are not considerd as refactoring.
//
// To achieve high code coverage it is essential that refactored code gets properly
// tested and covered by tests. It is advised that when refactoring a class
// or a method, it is important to also write tests to make sure it gets 100% covered.
//
// Typically 90% of a class is easy to cover by tests and 10% is hard to reach 
// through tests. It means that this 10% remaining is not easily testable, which 
// means it is not well designed, which often means that this code is especially 
// **error-prone**. This is the reason why it is important to reach 100% coverage
// for a class, to make sure that potentially *error-prone* code gets tested.
//</Description>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Blocker Issues" Unit="issues" />
failif count > 0 issues
from i in Issues
where i.Severity == Severity.Blocker
select new { i, i.Severity, i.Debt, i.AnnualInterest }

//<Description>
// An issue with the severity **Blocker** cannot move to production, it must be fixed.
//
// The severity of an issue is either defined explicitely in the rule source code,
// either inferred from the issue *annual interest* and thresholds defined in the 
// NDepend Project Properties > Issue and Debt.
//</Description>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Critical Issues" Unit="issues" />
failif count > 10 issues
warnif count > 0 issues

from i in Issues
where i.Severity == Severity.Critical
select new { i, i.Severity, i.Debt, i.AnnualInterest }

//<Description>
// An issue with a severity level **Critical** shouldn't move to production. 
// It still can for business imperative needs purposes, but at worst it must 
// be fixed during the next iterations. 
//
// The severity of an issue is either defined explicitely in the rule source code,
// either inferred from the issue *annual interest* and thresholds defined in the 
// NDepend Project Properties > Issue and Debt.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="New Blocker / Critical / Major Issues" Unit="issues" />
failif count > 0 issues
from i in Issues
where i.Severity.EqualsAny(Severity.Blocker, Severity.Critical, Severity.High) &&  
      // Count both the new issues and the issues that became at least Critical
      (i.WasAdded() || i.OlderVersion().Severity < Severity.High)
select new { i, i.Severity, i.Debt, i.AnnualInterest }


//<Description>
// An issue with the severity **Blocker** cannot move to production, it must be fixed.
//
// An issue with a severity level **Critical** shouldn't move to production. 
// It still can for business imperative needs purposes, but at worth it must be fixed 
// during the next iterations. 
//
// An issue with a severity level **High** should be fixed quickly, but can wait until 
// the next scheduled interval.
//
// The severity of an issue is either defined explicitely in the rule source code,
// either inferred from the issue *annual interest* and thresholds defined in the 
// NDepend Project Properties > Issue and Debt.
//</Description>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Critical Rules Violated" Unit="rules" />
failif count > 0 rules
from r in Rules where r.IsCritical && r.IsViolated()
select new { r, issues = r.Issues() }

//<Description>
// The concept of critical rule is useful to pinpoint certain rules that 
// should not be violated.
//
// A rule can be made critical just by checking the *Critical button* in the
// rule edition control and then saving the rule.
//
// This quality gate fails if any critical rule gets any violations.
//
// When no baseline is available, rules that rely on diff are not counted.
// If you observe that this quality gate count slightly decreases with no apparent reason,
// the reason is certainly that rules that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Percentage Debt" Unit="%" />
failif value > 30%
warnif value > 20%
let timeToDev = codeBase.EffortToDevelop()
let debt = Issues.Sum(i => i.Debt)
select 100d * debt.ToManDay() / timeToDev.ToManDay()

// <Description>
// % Debt total is defined as a percentage on:
//
// • the estimated total effort to develop the code base
//
// • and the the estimated total time to fix all issues (the Debt)
//
// Estimated total effort to develop the code base is inferred from 
// # lines of code of the code base and from the 
// *Estimated number of man-dat to develop 1000 logicial lines of code*
// setting found in NDepend Project Properties > Issue and Debt.
//
// Debt documentation: http://www.ndepend.com/Doc_TechnicalDebt#Debt
//
// This quality gates fails if the estimated debt is more than 30%
// of the estimated effort to develop the code base, and warns if the 
// estimated debt is more than 20% of the estimated effort to develop 
// the code base
// </Description>]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Debt" Unit="man-days" />
failif value > 50 man-days
warnif value > 30 man-days
Issues.Sum(i => i.Debt).ToManDay()

//<Description>
// This Quality Gate is disabled per default because the fail and warn 
// thresholds of unacceptable Debt in man-days can only depend on the 
// project size, number of developers and overall context.
//
// However you can refer to the default Quality Gate **Percentage Debt**.
//
// The Debt is defined as the sum of estimated effort to fix all issues.
// Debt documentation: http://www.ndepend.com/Doc_TechnicalDebt#Debt
//</Description>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="New Debt since Baseline" Unit="man-days" />
failif value > 2 man-days
warnif value > 0 man-days
let debt = Issues.Sum(i => i.Debt)
let debtInBaseline = IssuesInBaseline.Sum(i => i.Debt)
select (debt - debtInBaseline).ToManDay()


//<Description>
// This Quality Gate fails if the estimated effort to fix new or worsened
// issues (what is called the *New Debt since Baseline*) is higher
// than 2 man-days.
//
// This Quality Gate warns if this estimated effort is positive.
//
// Debt documentation: http://www.ndepend.com/Doc_TechnicalDebt#Debt
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Debt Rating per Namespace" Unit="namespaces" />
failif count > 0 namespaces

from n in Application.Namespaces
where n.DebtRating() != null &&
      n.DebtRating().Value.EqualsAny(DebtRating.E, DebtRating.D)
select new { 
   n, 
   debtRating = n.DebtRating(),
   debtRatio = n.DebtRatio(),  // % of debt from which DebtRating is inferred
   devTimeInManDay = n.EffortToDevelop().ToDebt(), 
   debtInManDay = n.AllDebt(),
   issues = n.AllIssues() 
}

// <Description>
// Forbid namespaces with a poor Debt Rating equals to **E** or **D**.
//
// The **Debt Rating** for a code element is estimated by the value of the **Debt Ratio**
// and from the various rating thresholds defined in this project *Debt Settings*. 
//
// The **Debt Ratio** of a code element is a percentage of **Debt Amount** (in floating man-days) 
// compared to the **estimated effort to develop the code element** (also in floating man-days).
//
// The **estimated effort to develop the code element** is inferred from the code elements
// number of lines of code, and from the project *Debt Settings* parameters 
// *estimated number of man-days to develop 1000* **logical lines of code**.
//
// The **logical lines of code** corresponds to the number of debug breakpoints in a method
// and doesn't depend on code formatting nor comments.
//
// The Quality Gate can be modified to match assemblies, types or methods
// with a poor Debt Rating, instead of matching namespaces.
// </Description>]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Annual Interest" Unit="man-days" />
failif value > 50 man-days
warnif value > 30 man-days
Issues.Sum(i => i.AnnualInterest).ToManDay()


//<Description>
// This Quality Gate is disabled per default because the fail and warn 
// thresholds of unacceptable Annual-Interest in man-days can only depend
// on the project size, number of developers and overall context.
//
// However you can refer to the default Quality Gate 
// **New Annual Interest since Baseline**.
//
// The Annual-Interest is defined as the sum of estimated annual cost
// in man-days, to leave all issues unfixed.
//
// Each rule can either provide a formula to compute the Annual-Interest 
// per issue, or assign a **Severity** level for each issue. Some thresholds
// defined in *Project Properties > Issue and Debt > Annual Interest* are
// used to infer an Annual-Interest value from a Severity level.
// Annual Interest documentation: http://www.ndepend.com/Doc_TechnicalDebt#AnnualInterest
//</Description>


]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="New Annual Interest since Baseline" Unit="man-days" />
failif value > 2 man-days
warnif value > 0 man-days
let ai = Issues.Sum(i => i.AnnualInterest)
let aiInBaseline = IssuesInBaseline.Sum(i => i.AnnualInterest)
select (ai - aiInBaseline).ToManDay()

//<Description>
// This Quality Gate fails if the estimated annual cost to leave all issues
// unfixed, increased from more than 2 man-days since the baseline.
//
// This Quality Gate warns if this estimated annual cost is positive.
//
// This estimated annual cost is named the **Annual-Interest**.
//
// Each rule can either provide a formula to compute the Annual-Interest 
// per issue, or assign a **Severity** level for each issue. Some thresholds
// defined in *Project Properties > Issue and Debt > Annual Interest* are
// used to infer an Annual-Interest value from a Severity level.
// Annual Interest documentation: http://www.ndepend.com/Doc_TechnicalDebt#AnnualInterest
//</Description>

]]></Query>
    </Group>
    <Group Name="Code Smells" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Files too big - critical</Name>
warnif count > 0 from f in Files where 
   f.NbLinesOfCode > 3000
   orderby f.NbLinesOfCode descending
select new { 
f, 
f.NbLinesOfCode,
  Debt = (f.NbLinesOfCode.Linear(200, 1, 2000, 10)).ToHours().ToDebt(),

   // The annual interest varies linearly from interest for severity major for 300 loc
   // to interest for severity critical for 2000 loc
   AnnualInterest = f.NbLinesOfCode.Linear(
                          200,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                          2000, Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes).ToMinutes().ToAnnualInterest()
}

// Files where NbLinesOfCode > 2000 are extremely complex 
// and should be split in a smaller group of files. 
// See the definition of the NbLinesOfCode metric here 
// http://www.cppdepend.com/Metrics.aspx#NbLinesOfCode

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid types with too many fields</Name>
warnif count > 0 from t in JustMyCode.Types 

  // Optimization: Fast discard of non-relevant types 
  where !t.IsEnumeration &&
         t.Fields.Count() > 15
        
  // Count instance fields and non-constant static fields
  let fields = t.Fields.Where(f =>
          !f.IsGeneratedByCompiler &&        
          !(f.IsStatic ) &&
           JustMyCode.Contains(f) )

  where fields.Count() > 15
 
  let methodsAssigningFields = fields.SelectMany(f => f.MethodsAssigningMe)

  orderby fields.Count() descending
select new { 
   t, 
   instanceFields = fields.Where(f => !f.IsStatic),
   staticFields = fields.Where(f => f.IsStatic),
methodsAssigningFields ,   

   Debt = fields.Count().Linear(15, 1, 200, 10).ToHours().ToDebt(),

   // The annual interest varies linearly from interest for severity major for 30 methods
   // to interest for severity critical for 200 methods
   AnnualInterest = fields.Count().Linear(15,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                                          200, Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes).ToMinutes().ToAnnualInterest()
}

//<Description>
// This rule matches types with more than 15 fields. 
// Such type might be hard to understand and maintain.
//
// Notice that constant fields and static-readonly fields are not counted.
// Enumerations types are not counted also.
//
// Having many fields for a type might be a symptom
// of too many responsibilities implemented.
//</Description>

//<HowToFix>
// To refactor such type and increase code quality and maintainability,
// certainly you'll have to group subsets of fields into smaller types
// and dispatch the logic implemented into the methods 
// into these smaller types.
//
// More refactoring advices can be found in the default rule 
// **Types to Big**, *HowToFix* section.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 1 hour for a type with 15 fields,
// to up to 10 hours for a type with 200 or more fields. 
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Avoid methods too big, too complex</Name>
warnif count > 0 from m in JustMyCode.Methods where 
    (m.NbLinesOfCode > 35 ||
   m.CyclomaticComplexity > 20)

  let complexityScore = m.NbLinesOfCode/2 + m.CyclomaticComplexity 

  orderby complexityScore descending,
          m.CyclomaticComplexity descending
select new { 
   m, 
   m.NbLinesOfCode,
   m.CyclomaticComplexity, 
   complexityScore,

   Debt = complexityScore.Linear(30, 40,    400, 8*60).ToMinutes().ToDebt(),

   // The annual interest varies linearly from interest for severity minor 
   // to interest for severity major
   AnnualInterest = complexityScore .Linear(30,     Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                                            200, 2*(Severity.High.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
   
}

//<Description>
// This rule matches methods where *ILNestingDepth* > 2
// and (*NbLinesOfCode* > 35 
// or *CyclomaticComplexity* > 20
// Such method is typically hard to understand and maintain.
//
// Maybe you are facing the **God Method** phenomenon.
// A "God Method" is a method that does way too many processes in the system 
// and has grown beyond all logic to become *The Method That Does Everything*.
// When need for new processes increases suddenly some programmers realize: 
// why should I create a new method for each processe if I can only add an *if*.
//
// See the definition of the *CyclomaticComplexity* metric here:
// http://www.cppdepend.com/Metrics.aspx#CC
//
//</Description>

//<HowToFix>
// A large and complex method should be split in smaller methods, 
// or even one or several classes can be created for that.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// Large *switch…case* structures might be refactored through the help
// of a set of types that implement a common interface, the interface polymorphism
// playing the role of the *switch cases tests*.
//
// Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//
// The estimated Debt, which means the effort to fix such issue,
// varies from 40 minutes to 8 hours, linearly from a weighted complexity score.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Avoid methods with too many parameters</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.NbParameters >= 7
  orderby m.NbParameters descending
select new { 
   m, 
   m.NbParameters,

   Debt = m.NbParameters.Linear(7, 1,  40, 6).ToHours().ToDebt(),

   // The annual interest varies linearly from interest for severity Minor for 7 parameters
   // to interest for severity Critical for 40 parameters
   AnnualInterest = m.NbParameters.Linear(7,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                                          40, Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes).ToMinutes().ToAnnualInterest()
}

//<Description>
// This rule matches methods with more than 8 parameters.
// Such method is painful to call and might degrade performance.
// See the definition of the *NbParameters* metric here: 
// http://www.cppdepend.com/Metrics.aspx#NbParameters
//</Description>

//<HowToFix>
// More properties/fields can be added to the declaring type to 
// handle numerous states. An alternative is to provide 
// a class or a structure dedicated to handle arguments passing.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 1 hour for a method with 7 parameters,
// up to 6 hours for a methods with 40 or more parameters.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid methods with too many local variables</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.NbVariables > 15 
  orderby m.NbVariables descending
select new { 
   m, 
   m.NbVariables,

   Debt = m.NbVariables.Linear(15, 1,   80, 6).ToHours().ToDebt(),

   // The annual interest varies linearly from interest for severity Minor for 15 variables
   // to interest for severity Critical for 80 variables
   AnnualInterest = m.NbVariables.Linear(15,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                                         80,  Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes).ToMinutes().ToAnnualInterest()

}

//<Description>
// This rule matches methods with more than 15 variables.
//
// Methods where *NbVariables > 8* are hard to understand and maintain.
// Methods where *NbVariables > 15* are extremely complex and must be refactored. 
//
// See the definition of the *Nbvariables* metric here: 
// http://www.cppdepend.com/Metrics.aspx#Nbvariables
//</Description>

//<HowToFix>
// To refactor such method and increase code quality and maintainability,
// certainly you'll have to split the method into several smaller methods
// or even create one or several classes to implement the logic.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 10 minutes for a method with 15 variables,
// up to 2 hours for a methods with 80 or more variables.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid methods with too many overloads</Name>
warnif count > 0 from m in JustMyCode.Methods where 
   m.NbOverloads >= 6 && 
  !m.IsOperator // Don't report operator overload
  orderby m.NbOverloads descending
let overloads = 
 m.IsConstructor ? m.ParentType.Constructors :
                   m.ParentType.Methods.Where(m1 => m1.SimpleName == m.SimpleName)
select new { 
   m, 
   overloads,
   Debt = 2.ToMinutes().ToDebt(),
   Severity = Severity.Medium
}

//<Description>
// Method overloading is the ability to create multiple methods of the same name 
// with different implementations, and various set of parameters.
//
// This rule matches sets of methods with 6 overloads or more.
//
// Such method set might be a problem to maintain 
// and provokes coupling higher than necessary.
//
// See the definition of the *NbOverloads* metric here 
// http://www.cppdepend.com/Metrics.aspx#NbOverloads
//</Description>

//<HowToFix>
// Typically the *too many overloads* phenomenon appears when an algorithm
// takes a various set of in-parameters. Each overload is presented as 
// a facility to provide a various set of in-parameters.
// In such situation, the C# and VB.NET language feature named 
// *Named and Optional arguments* should be used.
//
// The *too many overloads* phenomenon can also be a consequence of the usage
// of the **visitor design pattern** http://en.wikipedia.org/wiki/Visitor_pattern 
// since a method named *Visit()* must be provided for each sub type.
// In such situation there is no need for fix.
//
// Sometime *too many overloads* phenomenon is not the symptom of a problem,
// for example when a *numeric to something conversion* method applies to 
// all numeric and nullable numeric types.
//
// The estimated Debt, which means the effort to fix such issue,
// is of 2 minutes per method overload.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid methods potentially poorly commented</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.PercentageComment < 20 && 
  m.NbLinesOfCode > 20  

  let nbLinesOfCodeNotCommented = m.NbLinesOfCode - m.NbLinesOfComment

  orderby nbLinesOfCodeNotCommented descending

select new { 
   m, 
   m.PercentageComment, 
   m.NbLinesOfCode, 
   m.NbLinesOfComment,
   nbLinesOfCodeNotCommented,

   Debt = nbLinesOfCodeNotCommented .Linear(20, 2,  200, 20).ToMinutes().ToDebt(),

   // The annual interest varies linearly from interest for severity major for 300 loc
   // to interest for severity critical for 2000 loc
   AnnualInterest = m.PercentageComment.Linear(
                         0,  8 *(Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes), 
                         20,     Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes).ToMinutes().ToAnnualInterest()  
}

//<Description>
// This rule matches methods with less than 20% of comment lines and that have 
// at least 20 lines of code. Such method might need to be more commented.
//
// See the definitions of the *Comments metric* here:
// http://www.cppdepend.com/Metrics.aspx#PercentageComment
// http://www.cppdepend.com/Metrics.aspx#NbLinesOfComment
// 
// Notice that only comments about the method implementation
// (comments in method body) are taken account.
//</Description>

//<HowToFix>
// Typically add more comment. But code commenting is subject to controversy.
// While poorly written and designed code would needs a lot of comment 
// to be understood, clean code doesn't need that much comment, especially
// if variables and methods are properly named and convey enough information.
// Unit-Test code can also play the role of code commenting.
//
// However, even when writing clean and well-tested code, one will have
// to write **hacks** at a point, usually to circumvent some API limitations or bugs.
// A hack is a non-trivial piece of code, that doesn't make sense at first glance,
// and that took time and web research to be found.
// In such situation comments must absolutely be used to express the intention, 
// the need for the hacks and the source where the solution has been found.
//
// The estimated Debt, which means the effort to comment such method,
// varies linearly from 2 minutes for 10 lines of code not commented,
// up to 20 minutes for 200 or more, lines of code not commented.
//</HowToFix>]]></Query>
    </Group>
    <Group Name="Code Smells Regression" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>From now, all files added should respect basic quality principles</Name>
warnif count > 0 from f in JustMyCode.Files where

// Only match files added since Baseline.

   f.WasAdded() &&

// Eliminate interfaces, enumerations or types only with constant fields
// by making sure we are matching type with code.
f.NbLinesOfCode > 1000 
select new { 
   f, 
   f.NbLinesOfCode, 

   // Constant Debt estimation, since for such type rules in category "Code Quality" 
   // accurately estimate the Debt.
   Debt     = 10.ToMinutes().ToDebt(),

   // The Severity is higher for new types than for refactored types 
   AnnualInterest= (f.WasAdded() ? 3 : 1) *
                    Severity.High.AnnualInterestThreshold()
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on types added since baseline.
//
// This rule can be easily modified to also match types refactored since baseline,
// that don't satisfy all quality criterions.
//
// Files matched by this rule not only have been recently added or refactored,
// but also somehow violate one or several basic quality principles,
// whether it has too many methods,
// it has too many fields,
// or is using too many types.
// Any of these criterions is often a symptom of a type with too many responsibilities.
//
// Notice that to count methods and fields, methods like constructors 
// or property and event accessors are not taken account.
// Notice that constants fields and static-readonly fields are not counted.
// Enumerations types are not counted also.
//</Description>

//<HowToFix>
// To refactor such file and increase code quality and maintainability,
// certainly you'll have to split the type into several smaller types
// that together, implement the same logic.
//
// Issues of this rule have a constant 10 minutes Debt, because the Debt,
// which means the effort to fix such issue, is already estimated for issues
// of rules in the category **Code Quality**.
//
// However issues of this rule have a **High** severity, with even more 
// interests for issues on new types since baseline, because the proper time 
// to increase the quality of these types is **now**, before they get commited 
// in the next production release.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>From now, all methods added should respect basic quality principles</Name>
warnif count > 0 from m in JustMyCode.Methods where

// Only match methods added since Baseline.
// Uncomment this line to match also refactored methods since Baseline.
// (m.WasAdded() || m.CodeWasChanged()) &&
   m.WasAdded() &&
 
// Low Quality methods// Metrics' definitions
(  m.NbLinesOfCode > 30 ||          // http://www.cppdepend.com/Metrics.aspx#NbLinesOfCode
   m.CyclomaticComplexity > 20 ||   // http://www.cppdepend.com/Metrics.aspx#CC
   m.NbParameters > 5 ||            // http://www.cppdepend.com/Metrics.aspx#NbParameters
   m.NbVariables > 8                // http://www.cppdepend.com/Metrics.aspx#NbVariables
    )
select new { 
   m, 
   m.NbLinesOfCode,
   m.CyclomaticComplexity, 
   m.NbParameters, 
   m.NbVariables,
  

   // Constant Debt estimation, since for such method rules in category "Code Quality" 
   // accurately estimate the Debt.
   Debt     = 5.ToMinutes().ToDebt(),

   // The Severity is higher for new methods than for refactored methods
   AnnualInterest= (m.WasAdded() ? 3 : 1) *
                   Severity.High.AnnualInterestThreshold()
}  

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on methods added or refactored since the baseline.
//
// This rule can be easily modified to also match methods refactored since baseline,
// that don't satisfy all quality criterions.
//
// Methods matched by this rule not only have been recently added or refactored,
// but also somehow violate one or several basic quality principles,
// whether it is too large (too many *lines of code*), 
// too complex (too many *if*, *switch case*, loops…)
// has too many variables, too many parameters
// or has too many overloads.
//</Description>

//<HowToFix>
// To refactor such method and increase code quality and maintainability,
// certainly you'll have to split the method into several smaller methods
// or even create one or several classes to implement the logic.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// Large *switch…case* structures might be refactored through the help
// of a set of types that implement a common interface, the interface polymorphism
// playing the role of the *switch cases tests*.
//
// Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//
// Issues of this rule have a constant 5 minutes Debt, because the Debt,
// which means the effort to fix such issue, is already estimated for issues
// of rules in the category **Code Quality**.
// 
// However issues of this rule have a **High** severity, with even more 
// interests for issues on new methods since baseline, because the proper time 
// to increase the quality of these methods is **now**, before they get commited 
// in the next production release.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid making complex methods even more complex</Name>
warnif count > 0 

let complexityScoreProc = new Func<IMethod, double>(m => 
    (m.CyclomaticComplexity ).Value)

from m in JustMyCode.Methods where
  m.IsPresentInBothBuilds() &&
  m.CodeWasChanged() &&
  m.OlderVersion().CyclomaticComplexity > 6 

let complexityScore = complexityScoreProc(m)
let oldComplexityScore = complexityScoreProc(m.OlderVersion())
where complexityScore > oldComplexityScore 

let complexityScoreDiff = complexityScoreProc(m) - complexityScoreProc(m.OlderVersion())
orderby complexityScoreDiff descending

select new { 
   m,
   oldComplexityScore ,
   complexityScore ,
   diff= complexityScoreDiff,

   Debt = complexityScoreDiff.Linear(1, 15,   50, 60).ToMinutes().ToDebt(),

   // The annual interest varies linearly from interest for severity Minor for a tiny complexity increment
   // to interest for severity critical for 2000 loc
   AnnualInterest = complexityScoreDiff.Linear(1,     Severity.High.AnnualInterestThreshold().Value.TotalMinutes, 
                                               50, 4*(Severity.High.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
   
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// The method complexity is measured through the code metric
// *Cyclomatic Complexity* defined here:
// http://www.cppdepend.com/Metrics.aspx#CC
//
// This rule warns when a method already complex
// (i.e with *Cyclomatic Complexity* higher than 6)
// become even more complex since the baseline.
//
//
// To visualize changes in code, right-click a matched method and select:
//
// • Compare older and newer versions of source file
//
// • or Compare older and newer versions disassembled with Reflector
//</Description>

//<HowToFix>
// A large and complex method should be split in smaller methods, 
// or even one or several classes can be created for that.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// Large *switch…case* structures might be refactored through the help
// of a set of types that implement a common interface, the interface polymorphism
// playing the role of the *switch cases tests*.
//
// Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 15 to 60 minutes depending on the extra complexity added.
//
// Issues of this rule have a **High** severity, because it is important to focus 
// on these issues **now**, before such code gets released in production.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid making large methods even larger</Name>

warnif count > 0 
from m in JustMyCode.Methods where


  // Filter just here for optimization
  m.NbLinesOfCode > 15 &&

  m.IsPresentInBothBuilds() &&
  m.CodeWasChanged() 

let oldLoc = m.OlderVersion().NbLinesOfCode
where oldLoc > 15 && m.NbLinesOfCode > oldLoc

let diff = m.NbLinesOfCode - oldLoc
where diff > 0
orderby diff descending 

select new { 
   m,
   oldLoc,
   newLoc = m.NbLinesOfCode,
   diff,

   Debt = diff.Linear(1, 10,   100, 60).ToMinutes().ToDebt(),

   // The annual interest varies linearly from interest for severity Minor for a tiny complexity increment
   // to interest for severity critical for 2000 loc
   AnnualInterest = diff .Linear(1,      Severity.High.AnnualInterestThreshold().Value.TotalMinutes, 
                                 100, 4*(Severity.High.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
   
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This rule warns when a method already large
// (i.e with more than 15 lines of code)
// become even larger since the baseline.
//
// The method size is measured through the code metric
// *# Lines of Code* defined here:
// http://www.cppdepend.com/Metrics.aspx#NbLinesOfCode
//
// To visualize changes in code, right-click a matched method and select:
//
// • Compare older and newer versions of source file
//</Description>

//<HowToFix>
// Usually too big methods should be split in smaller methods.
//
// But long methods with no branch conditions, that typically initialize some data,
// are not necessarily a problem to maintain, and might not need refactoring.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 5 to 20 minutes depending 
// on the number of lines of code added.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 10 to 60 minutes depending on the extra complexity added.
//
// Issues of this rule have a **High** severity, because it is important to focus 
// on these issues **now**, before such code gets released in production.
//</HowToFix>]]></Query>
    </Group>
    <Group Name="CWE Rules" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && (issue.Type=="bufferAccessOutOfBounds" || issue.Type=="possibleBufferAccessOutOfBounds"
 || issue.Type=="insecureCmdLineArgs"|| issue.Type=="invalidscanf") select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Divide By Zero</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="zerodiv"  select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Unchecked Error Condition</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="zerodiv"  select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Unexpected Status Code or Return Value</Name>
warnif count > 0 
from issue in ImportedIssues where  issue.Type=="emptycatch"  select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Declaration of Throws for Generic Exception</Name>
warnif count > 0 
from issue in ImportedIssues where  issue.Type=="genericexception"  select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Improper Release of Memory Before Removing Last Reference ('Memory Leak')</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && (issue.Type=="memleak" || issue.Type=="memleakOnRealloc"
 || issue.Type=="publicAllocationError"|| issue.Type=="leakNoVarFunctionCall") select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Double Free</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="deallocDealloc"  select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use of Uninitialized Variable</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="uninitvar" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    } ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Incomplete Cleanup</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="resourceLeak"  select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>NULL Pointer Dereferenced</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="nullPointer"  select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use of Obsolete Functions</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CLang" && issue.Type=="warn_deprecated"  select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Missing Default Case in Switch Statement</Name>
warnif count > 0 
from issue in ImportedIssues where issue.Type=="Rule6-4-6"
select issue ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Assigning instead of Comparing</Name>
warnif count > 0 
from issue in ImportedIssues where issue.Type=="Rule6-2-1"
select issue ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Comparing instead of Assigning</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CLang" && issue.Type=="warn_unused_comparison"  select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Omitted Break Statement in Switch</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="warn_unannotated_fallthrough" select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Leftover Debug Code</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="knownConditionTrueFalse" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    } ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Dead Code</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="warn_unreachable" select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Assignment to Variable without Use ('Unused Variable')</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unreadVariable" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    } ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Expression is Always False</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="knownConditionTrueFalse"  && issue.Description.Contains("always false")
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    } ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Expression is Always True</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="knownConditionTrueFalse"  && issue.Description.Contains("always true")
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }  ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Function Call with Incorrectly Specified Arguments</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="preprocessorErrorDirective"  && issue.Description.Contains("Wrong number")
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }  ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use of Potentially Dangerous Function</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="dangerousUsageStrtol" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    } ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Operator Precedence Logic Error</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && (issue.Type=="clarifyCalculation" || issue.Type=="clarifyCondition")
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
 ]]></Query>
    </Group>
    <Group Name="Memory Management" Active="True" ShownInReport="False">
      <Group Name="Leaks" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Returning/dereferencing p after it is deallocated / released</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="deallocret" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Memory pointed to by varname is freed twice.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="doubleFree" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Allocation with funcName, funcName doesnt release it.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="leakNoVarFunctionCall" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Return value of allocation function funcName is not stored.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="leakReturnValNotUsed" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Possible leak in public function. The pointer varname is not deallocated before it is allocated.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="publicAllocationError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Class class is unsafe, class::varname can leak by wrong usage.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unsafeClassCanLeak" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Memory leak: varname</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="memleak" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Resource leak: varname</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="resourceLeak" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Deallocating a deallocated pointer: varname</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="deallocDealloc" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Dereferencing varname after it is deallocated / released</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="deallocuse" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The allocated size sz is not a multiple of the underlying types size.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="mismatchSize" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Mismatching allocation and deallocation: varname</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="mismatchAllocDealloc" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Common realloc mistake: varname nulled but not freed upon failure</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="memleakOnRealloc" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      </Group>
      <Group Name="Null Pointer" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Null pointer dereference</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="nullPointer" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Possible null pointer dereference if the default parameter value is used: pointer</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="nullPointerDefaultArg" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Either the condition is redundant or there is possible null pointer dereference: pointer.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="nullPointerRedundantCheck" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      </Group>
      <Group Name="Auto Variables" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Address of local auto-variable assigned to a function parameter.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="autoVariables" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Address of an auto-variable returned.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="returnAddressOfAutoVariable" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Pointer to local array variable returned.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="returnLocalVariable" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Reference to auto variable returned.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="returnReference" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Reference to temporary returned.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="returnTempReference" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Deallocation of an auto-variable results in undefined behaviour.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="autovarInvalidDeallocation" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Address of function parameter parameter returned.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="returnAddressOfFunctionParameter" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Assignment of function parameter has no effect outside the function.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="uselessAssignmentArg" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Assignment of function parameter has no effect outside the function. Did you forget dereferencing it?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="uselessAssignmentPtrArg" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      </Group>
      <Group Name="Bounds Checking" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Array array[2] index array[1][1] out of bounds.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="arrayIndexOutOfBounds" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Buffer is accessed out of bounds: buffer</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="bufferAccessOutOfBounds" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Dangerous usage of strncat - 3rd parameter is the maximum number of characters to append.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="strncatUsage" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>index is out of bounds: Supplied size 2 is larger than actual size 1.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="outOfBounds" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The size argument is given as a char constant.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="sizeArgumentAsChar" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Array index -1 is out of bounds.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="negativeIndex" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Buffer overrun possible for long command line arguments.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="insecureCmdLineArgs" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Undefined behaviour, pointer arithmetic  is out of bounds.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="pointerOutOfBounds" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Array index index is used before limits check.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="arrayIndexThenCheck" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Possible buffer overflow if strlen(source) is larger than or equal to sizeof(destination).</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="possibleBufferAccessOutOfBounds" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The array array is too small, the function function expects a bigger one.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="argumentSize" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Memory allocation size is negative.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="negativeMemoryAllocationSize" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Declaration of array  with negative size is undefined behaviour</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="negativeArraySize" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Array x[10] accessed at index 20, which is out of bounds. Otherwise condition y==20 is redundant.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="arrayIndexOutOfBoundsCond" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      </Group>
    </Group>
    <Group Name="Primitive Types Usage" Active="True" ShownInReport="False">
      <Group Name="Boolean" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Boolean value assigned to pointer.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="assignBoolToPointer" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Boolean value assigned to floating point variable.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="assignBoolToFloat" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comparison of a function returning boolean value using relational (<, >, <= or >=) operator.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="comparisonOfFuncReturningBoolError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comparison of two functions returning boolean value using relational (<, >, <= or >=) operator.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="comparisonOfTwoFuncsReturningBoolError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comparison of a variable having boolean value using relational (<, >, <= or >=) operator.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="comparisonOfBoolWithBoolError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Incrementing a variable of type bool with postfix operator++ is deprecated by the C++ Standard. You should assign it the value true instead.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="incrementboolean" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comparison of a boolean expression with an integer other than 0 or 1.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="compareBoolExpressionWithInt" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Converting pointer arithmetic result to bool. The bool is always true unless there is undefined behaviour.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="pointerArithBool" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      </Group>
      <Group Name="String" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Modifying string literal directly or indirectly is undefined behaviour.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="stringLiteralWrite" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Undefined behavior: Variable varname is used as parameter and destination in s[n]printf().</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="sprintfOverlappingData" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Unusual pointer arithmetic. A value of type char is added to a string literal.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="strPlusChar" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>String literal Hello World doesnt match length argument for substr().</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="incorrectStringCompare" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>String literal compared with variable foo. Did you intend to use strcmp() instead?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="literalWithCharPtrCompare" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Char literal compared with pointer foo. Did you intend to dereference it?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="charLiteralWithCharPtrCompare" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Conversion of string literal Hello World to bool always evaluates to true.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="incorrectStringBooleanError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Unnecessary comparison of static strings.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="staticStringCompare" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comparison of identical string variables.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="stringCompare" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      </Group>
      <Group Name="Type" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Shifting 32-bit value by 64 bits is undefined behaviour</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="shiftTooManyBits" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Signed integer overflow for expression .</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="integerOverflow" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Suspicious code: sign conversion of var in calculation, even though var can have a negative value</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="signConversion" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>int result is assigned to long variable. If the variable is long to avoid loss of information, then you have loss of information.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="truncLongCastAssignment" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>int result is returned as long value. If the return value is long to avoid loss of information, then you have loss of information.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="truncLongCastReturn" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      </Group>
    </Group>
    <Group Name="Misc" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Either the condition is redundant or there is division by zero at line 0.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="zerodivcond" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Instance of varname object is destroyed immediately.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unusedScopedObject" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Casting between float* and double* which have an incompatible binary data representation.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="invalidPointerCast" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Shifting a negative value is undefined behaviour</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="shiftNegative" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Buffer varname must have size of 2 integers if used as parameter of pipe().</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="wrongPipeParameterSize" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="raceAfterInterlockedDecrement" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Buffer var is being written before its old content has been used.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="redundantCopy" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Variable var is reassigned a value before the old one has been used.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="redundantAssignment" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comparison of two identical variables with isless(varName,varName) always evaluates to false.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="comparisonFunctionIsAlwaysTrueOrFalse" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Storing func_name() return value in char variable and then comparing with EOF.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="checkCastIntToCharAndBack" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Function parameter parametername should be passed by reference.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="passedByValue" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Redundant code: Found a statement that begins with type constant.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="constStatement" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Signed char type used as array index.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="signedCharArrayIndex" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>char type used as array index.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unknownSignCharArrayIndex" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>When using char variables in bit operations, sign extension can generate unexpected results.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="charBitOp" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The scope of the variable varname can be reduced.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="variableScope" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Variable var is reassigned a value before the old one has been used. break; missing?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="redundantAssignInSwitch" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Buffer var is being written before its old content has been used. break; missing?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="redundantCopyInSwitch" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Redundant assignment of varname to itself.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="selfAssignment" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>memset() called to fill 0 bytes.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="memsetZeroBytes" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The 2nd memset() argument varname is a float, its representation is implementation defined.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="memsetFloat" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The 2nd memset() argument varname doesnt fit into an unsigned char.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="memsetValueOutOfRange" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Clarify calculation precedence for + and ?.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="clarifyCalculation" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Ineffective statement similar to *A++;. Did you intend to write (*A)++;?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="clarifyStatement" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Same expression on both sides of &&.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="duplicateExpression" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Same expression in both branches of ternary operator.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="duplicateExpressionTernary" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Consecutive return, break, continue, goto or throw statements are unnecessary.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="duplicateBreak" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Statements following return, break, continue, goto or throw will never be executed.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unreachableCode" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Checking if unsigned variable varname is less than zero.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unsignedLessThanZero" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Unsigned variable varname cant be negative so it is unnecessary to test it.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unsignedPositive" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>A pointer can not be negative so it is either pointless or an error to check if it is.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="pointerLessThanZero" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>A pointer can not be negative so it is either pointless or an error to check if it is not.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="pointerPositive" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="varFuncNullUB" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Using NaN/Inf in a computation.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="nanInArithmeticExpression" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comma is used in return statement. The comma can easily be misread as a ;.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="commaSeparatedReturn" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Redundant pointer operation on varname - its already a pointer.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="redundantPointerOp" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Label  is not used. Should this be a case of the enclosing switch()?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unusedLabelSwitch" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Label  is not used.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unusedLabel" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Expression x = x++; depends on order of evaluation of side effects</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unknownEvaluationOrder" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Prefer prefix ++/-- operators for non-primitive types.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="postfixOperator" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
    </Group>
    <Group Name="Code Diff Summary" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New Projects</Name>
from a in Application.Projects where a.WasAdded()
select new { a, a.NbLinesOfCode }

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects removed</Name>
from a in codeBase.OlderVersion().Application.Projects where a.WasRemoved()
select new { a, a.NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects where code was changed</Name>
from a in Application.Projects where a.CodeWasChanged()
select new { a, a.NbLinesOfCode, 
             oldNbLinesOfCode = a.OlderVersion().NbLinesOfCode ,
             delta = (int) a.NbLinesOfCode - a.OlderVersion().NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New files</Name>
from f in Application.Files where 
 !f.ParentProject.WasAdded() &&
  f.WasAdded()
select new { f, f.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Files removed</Name>
from f in codeBase.OlderVersion().Application.Files where 
 !f.ParentProject.WasRemoved() &&
  f.WasRemoved()
select new { f, f.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Files where code was changed</Name>
from f in Application.Files where f.CodeWasChanged()
select new { f, f.NbLinesOfCode, 
             oldNbLinesOfCode = f.OlderVersion().NbLinesOfCode ,
             delta = (int) f.NbLinesOfCode - f.OlderVersion().NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New methods</Name>
from m in Application.Methods where 
 !m.ParentType.WasAdded() &&
  m.WasAdded()
select new { m, m.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods removed</Name>
from m in codeBase.OlderVersion().Application.Methods where 
 !m.ParentType.WasRemoved() &&
  m.WasRemoved()
select new { m, m.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods where code was changed</Name>
// To visualize changes in code, right-click a matched method and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector

from m in Application.Methods where m.CodeWasChanged()
select new { m, m.NbLinesOfCode, 
             oldNbLinesOfCode = m.OlderVersion().NbLinesOfCode ,
             delta = (int?) m.NbLinesOfCode - m.OlderVersion().NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods directly calling one or several methods changed</Name>
let methodsChanged = Application.Methods.Where(m => m.CodeWasChanged()).ToHashSetEx()

from m in JustMyCode.Methods.UsingAny(methodsChanged ) where
  !m.CodeWasChanged() && 
  !m.WasAdded()
let methodsChangedCalled = m.MethodsCalled.Intersect(methodsChanged) 
select new { m, methodsChangedCalled }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods indirectly calling one or several methods changed</Name>
let methodsChanged = Application.Methods.Where(m => m.CodeWasChanged()).ToHashSetEx()

// 'depth' represents a code metric defined on methods using
// directly or indirectly any method where code was changed.
let depth = JustMyCode.Methods.DepthOfIsUsingAny(methodsChanged) 

from m in depth.DefinitionDomain where
  !m.CodeWasChanged() && 
  !m.WasAdded()

let methodsChangedDirectlyUsed = m.MethodsCalled.Intersect(methodsChanged) 
let depthOfUsingMethodsChanged = depth[m]
orderby depthOfUsingMethodsChanged 

select new { m, depthOfUsingMethodsChanged, methodsChangedDirectlyUsed }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New fields</Name>
from f in Application.Fields where 
 !f.ParentType.WasAdded() &&
  f.WasAdded()
select new { f }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Fields removed</Name>
from f in codeBase.OlderVersion().Application.Fields where 
 !f.ParentType.WasRemoved() &&
  f.WasRemoved()
select new { f }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party methods that were not used and that are now used</Name>
from m in ThirdParty.Methods where 
  m.IsUsedRecently() &&
 !m.ParentType.IsUsedRecently()
select m]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party methods that were used and that are not used anymore</Name>
from m in codeBase.OlderVersion().Methods where 
  m.IsNotUsedAnymore() &&
 !m.ParentType.IsNotUsedAnymore()
select m]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party fields that were not used and that are now used</Name>
from f in ThirdParty.Fields where 
  f.IsUsedRecently() &&
 !f.ParentType.IsUsedRecently()
select f]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party fields that were used and that are not used anymore</Name>
from f in codeBase.OlderVersion().Fields where 
  f.IsNotUsedAnymore() &&
 !f.ParentType.IsNotUsedAnymore()
select f
]]></Query>
    </Group>
    <Group Name="Naming Conventions" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types name should begin with an Upper character</Name>
warnif count > 0 (from t in Types where 
 !t.NameLike (@"^[A-Z]")      // The name of a type should begin with an Upper letter.
  && // Except if it is generated by compiler or ...
 !t.IsThirdParty && !t.IsGlobal
select new { t, t.NbLinesOfCode }).Take(10)

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid types with name too long</Name>
warnif count > 0 from t in Application.Types 
where !t.IsGeneratedByCompiler && !t.IsThirdParty

where t.SimpleName.Length > 35 
select new { t, t.SimpleName }

      ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid methods with name too long</Name>
warnif count > 0 from m in Application.Methods where 
 !m.IsGeneratedByCompiler 
  && m.SimpleName.Length > 35 && !m.IsThirdParty

select new { m, m.SimpleName }

// The regex matches methods with name longer 
// than 35 characters.
// Method Name doesn't contain the type and namespace 
// prefix, FullName does.
// The regex computes the method name length from 
// the beginning until the first open parenthesis 
// or first lower than (for generic methods).
      ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid fields with name too long</Name>
warnif count > 0 from f in Application.Fields where
 !f.IsGeneratedByCompiler &&
  f.Name.Length > 35 && !f.IsThirdParty
select f

// The regex matches fields with name longer 
// than 35 characters.
// Field Name doesn't contain the type and 
// namespace prefix, FullName does.
      ]]></Query>
    </Group>
    <Group Name="Code Coverage" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>C.R.A.P method code metric</Name>

warnif count > 0
from m in JustMyCode.Methods

// Don't match too short methods
where m.NbLinesOfCode > 10

let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (CC * CC * uncov * uncov * uncov) + CC
where CRAP != null && CRAP > 30
orderby CRAP descending, m.NbLinesOfCode descending
select new { m, CRAP, CC, uncoveredPercentage = uncov*100, m.NbLinesOfCode }

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// **Change Risk Analyzer and Predictor** (i.e. CRAP) is a code metric
// that helps in pinpointing overly complex and untested code.
// Is has been first defined here: 
// http://www.artima.com/weblogs/viewpost.jsp?thread=215899
//
// The Formula is:  **CRAP(m) = CC(m)^2 * (1 – cov(m)/100)^3 + CC(m)**
//
// • where *CC(m)* is the *cyclomatic complexity* of the method *m*
//
// • and *cov(m)* is the *percentage coverage* by tests of the method *m*
//
// Matched methods cumulates two highly *error prone* code smells:
//
// • A complex method, difficult to develop and maintain.
//
// • Non 100% covered code, difficult to refactor without introducing any regression bug.
//
// The highest the CRAP score, the more painful to maintain and error prone is the method.
//
// An arbitrary threshold of 30 is fixed for this code rule as suggested by inventors.
//
// Notice that no amount of testing will keep methods with a Cyclomatic Complexity
// highest than 30, out of CRAP territory.
//
// Notice that this rule doesn't match too short method
// with less than 10 lines of code.
//</Description>

//<HowToFix>
// In such situation, it is recommended to both refactor the complex method logic
// into several smaller and less complex methods 
// (that might belong to some new types especially created),
// and also write unit-tests to full cover the refactored logic. 
//
// You'll find code impossible to cover by unit-tests, like calls to *MessageBox.Show()*.
// An infrastructure must be defined to be able to *mock* such code at test-time.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Complex methods partially covered by tests should be 100% covered</Name>

warnif count > 0 from m in JustMyCode.Methods 
 where 
    
     (  m.NbLinesOfCode > 30 || 
        m.CyclomaticComplexity > 30 || 
        m.NestingDepth > 4 || 
        m.NbVariables > 8) && 

     // Take care only of complex methods 
     // already partially covered, but not completely covered.
     m.PercentageCoverage > 0 &&
     m.PercentageCoverage < 100

  orderby m.NbLinesOfCodeNotCovered ascending,
          m.NbLinesOfCode descending
select new { m, m.PercentageCoverage, m.NbLinesOfCode, 
             m.NbLinesOfCodeCovered, m.NbLinesOfCodeNotCovered, 
             m.CyclomaticComplexity, m.NestingDepth, m.NbVariables }

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// There are default rules that warn about complex methods to refactor.
// The present rule warns about complex methods that are already a bit covered by tests
// but not 100% covered by tests.
//
// Such situation cumulates two highly *error prone* code smells:
//
// • A complex method, difficult to develop and maintain.
//
// • Non 100% covered code, difficult to refactor without creating any regression bug.
//
// Because the complex method is already covered partially by tests,
// it might be not so costly to write more tests to full cover it.
//</Description>

//<HowToFix>
// In such situation, it is recommended to both:
//
// • refactor the complex method logic
// into several smaller and less complex methods 
// (that might belong to some new types especially created),
//
// • and also write more unit-tests to full cover the refactored logic. 
//
// You'll find code impossible to cover by unit-tests, like calls to *MessageBox.Show()*.
// An infrastructure must be defined to be able to *mock* such code at test-time.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Method changed poorly covered</Name>
warnif count > 0
from m in Application.Methods where 
  m.PercentageCoverage < 30 && 
  m.CodeWasChanged() 
  orderby m.NbLinesOfCode descending, 
           m.NbLinesOfCodeNotCovered ,
           m.PercentageCoverage
select new { m, m.PercentageCoverage, m.NbLinesOfCode, 
             m.NbLinesOfCodeNotCovered }  

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on methods added or refactored since the baseline.
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// It is important to write code mostly covered by tests 
// to achieve *maintainable* and *non-error-prone* code.
//
// In real-world, many code bases are poorly covered by tests.
// However it is not practicable to stop the development for months
// to refactor and write tests to achieve high code coverage ratio.
//
// Hence it is recommended that each time a method (or a type) gets refactored,
// the developer takes the time to write associated unit-tests to cover it.
//
// Doing so will help to increase significantly the maintainability of the code base.
// You'll notice that quickly, refactoring will also be driven by testability, 
// and as a consequence, the overall code structure and design will increase as well.
//</Description>

//<HowToFix>
// Write unit-tests to cover the code of most methods and classes refactored.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Method added poorly covered</Name>
warnif count > 0
from m in Application.Methods where
  m.NbLinesOfCode > 0 &&
  m.PercentageCoverage < 30 && 
  m.WasAdded() 
  orderby m.NbLinesOfCode descending, 
           m.NbLinesOfCodeNotCovered ,
           m.PercentageCoverage
select new { m, m.PercentageCoverage, m.NbLinesOfCode, 
             m.NbLinesOfCodeNotCovered }

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on methods added or refactored since the baseline.
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// It is important to write code mostly covered by tests 
// to achieve *maintainable* and *non-error-prone* code.
//
// In real-world, many code bases are poorly covered by tests.
// However it is not practicable to stop the development for months
// to refactor and write tests to achieve high code coverage ratio.
//
// Hence it is recommended that each time a method (or a type) gets added,
// the developer takes the time to write associated unit-tests to cover it.
//
// Doing so will help to increase significantly the maintainability of the code base.
// You'll notice that quickly, refactoring will also be driven by testability, 
// and as a consequence, the overall code structure and design will increase as well.
//</Description>

//<HowToFix>
// Write unit-tests to cover the code of most methods and classes added.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types 95% to 99% covered</Name>
warnif count > 0
from t in Application.Types where 
  t.PercentageCoverage >= 95 && 
  t.PercentageCoverage <= 99 &&
 !t.IsGeneratedByCompiler

  let methodsCulprit = t.Methods.Where(m => m.PercentageCoverage < 100)

  orderby t.NbLinesOfCode descending , 
           t.NbLinesOfCodeNotCovered ,
           t.PercentageCoverage
select new { t, t.PercentageCoverage, t.NbLinesOfCode, 
             t.NbLinesOfCodeNotCovered, methodsCulprit } 

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// Often covering the few percents of remaining uncovered code of a class, 
// requires as much work as covering the first 90%.
// For this reason, often teams estimate that 90% coverage is enough.
// However *untestable code* usually means *poorly written code* 
// which usually leads to *error prone code*.
// So it might be worth refactoring and making sure to cover the few uncovered lines of code
// **because most tricky bugs might come from this small portion of hard-to-test code**.
//
// Not all classes should be 100% covered by tests (like UI code can be hard to test)
// but you should make sure that most of the logic of your application
// is defined in some *easy-to-test classes*, 100% covered by tests.
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover code not covered yet.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces 95% to 99% covered</Name>
warnif count > 0
from n in Application.Namespaces where 
  n.PercentageCoverage >= 95 && 
  n.PercentageCoverage <= 99 

  let methodsCulprit = n.ChildMethods.Where(m => m.PercentageCoverage < 100)

  orderby n.NbLinesOfCode descending , 
           n.NbLinesOfCodeNotCovered ,
           n.PercentageCoverage
select new { n, n.PercentageCoverage, n.NbLinesOfCode, 
             n.NbLinesOfCodeNotCovered, methodsCulprit  } 

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// Often covering the few percents of remaining uncovered code of 
// one or several classes in a namespace
// requires as much work as covering the first 90%.
// For this reason, often teams estimate that 90% coverage is enough.
// However *untestable code* usually means *poorly written code* 
// which usually leads to *error prone code*.
// So it might be worth refactoring and making sure to cover the few uncovered lines of code
// **because most tricky bugs might come from this small portion of hard-to-test code**.
//
// Not all classes should be 100% covered by tests (like UI code can be hard to test)
// but you should make sure that most of the logic of your application
// is defined in some *easy-to-test classes*, 100% covered by tests.
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover code not covered yet in the namespace.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types not covered at all</Name>
from t in Application.Types where 
  t.PercentageCoverage == 0
  orderby t.NbLinesOfCode descending
select new { t, t.NbLinesOfCode }

//<Description>
// This query is executed only if some code coverage data is imported
// from some code coverage files.
//
// This code query lists types not covered at all by any test.
//
// Often, when code is not covered at all by test, one can reach
// decent coverage ratio (like 50% to 90%) just by writing a few tests.
//
// The idea is not to cover code for the sake of it.
// The idea is that thanks to a small effort of writing a few tests,
// one can continuously check, that a significant portion of code 
// runs without a problem. 
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces not covered at all</Name>
from n in Application.Namespaces where 
  n.PercentageCoverage == 0
  orderby n.NbLinesOfCode descending
select new { n, n.NbLinesOfCode} 

//<Description>
// This query is executed only if some code coverage data is imported
// from some code coverage files.
//
// This code query lists namespaces not covered at all by any test.
//
// Often, when code is not covered at all by test, one can reach
// decent coverage ratio (like 50% to 90%) just by writing a few tests.
//
// The idea is not to cover code for the sake of it.
// The idea is that thanks to a small effort of writing a few tests,
// one can continuously check, that a significant portion of code 
// runs without a problem. 
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Test Methods</Name>

let testAttr = ThirdParty.Types.WithNameIn("TestAttribute", "TestCaseAttribute")
let testMethods = Methods.TaggedWithAnyAttributes(testAttr)
from m in testMethods 
select m

//<Description>
// We advise to not include test assemblies in code analyzed by NDepend.
// We estimate that it is acceptable and practical to lower the quality gate of test code,
// because the important measures for tests are:
//
// • The coverage ratio, 
//
// • And the amount of logic results asserted: This includes both
// assertions in test code, and assertions in code covered by tests, 
// like *Code Contract* assertions and *Debug.Assert(…)* assertions.
//
// But if you wish to enforce the quality of test code, you'll need to 
// consider test assemblies in your list of application assemblies 
// analyzed by NDepend.
//
// In such situation, this code query lists tests methods and you can 
// reuse this code in custom rules.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods directly called by test Methods</Name>

let testAttr = ThirdParty.Types.WithNameIn("TestAttribute", "TestCaseAttribute")
let testMethods = Methods.TaggedWithAnyAttributes(testAttr).ToHashSetEx()

// --- Uncomment this line if your test methods are in dedicated test assemblies ---
//let testAssemblies = testMethods.ParentAssemblies().ToHashSetEx()

from m in Application.Methods.UsedByAny(testMethods)

// --- Uncomment this line if your test methods are in dedicated test assemblies ---
//where !testAssemblies.Contains(m.ParentAssembly)

select new { m , 
             calledByTests = m.MethodsCallingMe.Intersect(testMethods ),
             // --- Uncomment this line if your project import some coverage data ---
             // m.PercentageCoverage 
}


//<Description>
// This query lists all methods directly called by tests methods.
// Overrides of virtual and abstract methods, called through polymorphism, are not listed.
// Methods solely invoked through a delegate are not listed.
// Methods solely invoked through reflection are not listed.
//
// We advise to not include test assemblies in code analyzed by NDepend.
// We estimate that it is acceptable and practical to lower the quality gate of test code,
// because the important measures for tests are:
//
// • The coverage ratio, 
//
// • And the amount of logic results asserted: This includes both
// assertions in test code, and assertions in code covered by tests, 
// like *Code Contract* assertions and *Debug.Assert(…)* assertions.
//
// But if you wish to run this code query,
// you'll need to consider test assemblies in your list of 
// application assemblies analyzed by NDepend.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods directly and indirectly called by test Methods</Name>

let testAttr = from t in ThirdParty.Types.WithNameIn("TestAttribute", "TestCaseAttribute") select t
let testMethods = Methods.TaggedWithAnyAttributes(testAttr)

// --- Uncomment this line if your test methods are in dedicated test assemblies ---
// let testAssemblies = testMethods.ParentAssemblies().ToHashSetEx()

let depthOfCalledByTest = Application.Methods.DepthOfIsUsedByAny(testMethods)
from pair in depthOfCalledByTest
where pair.Value > 0 
orderby pair.Value ascending
// --- Uncomment this line if your test methods are in dedicated test assemblies ---
//&& !testAssemblies.Contains(pair.CodeElement.ParentAssembly)

select new { 
  method = pair.CodeElement, 
  // (depthOfCalledByTests == 1) means that the method is directly called by tests
  // (depthOfCalledByTests == 2) means that the method is directly called by a method directly called by tests
  // …
  depthOfCalledByTests = pair.Value,
  nbLinesOfCode = pair.CodeElement.NbLinesOfCode,
  // --- Uncomment this line if your project import some coverage data ---
  // m.PercentageCoverage
}

//<Description>
// This query lists all methods *directly or indirectly* called by tests methods.
// *Indirectly* called by a test means that a test method calls a method, that calls a method…
// From this recursion, a code metric named *depthOfCalledByTests* is inferred,
// The value *1* means directly called by test,
// the value *2* means called by a method that is called by a test…
//
// Overrides of virtual and abstract methods, called through polymorphism, are not listed.
// Methods solely invoked through a delegate are not listed.
// Methods solely invoked through reflection are not listed.
//
// We advise to not include test assemblies in code analyzed by NDepend.
// We estimate that it is acceptable and practical to lower the quality gate of test code,
// because the important measures for tests are:
//
// • The coverage ratio, 
//
// • And the amount of logic results asserted: This includes both
// assertions in test code, and assertions in code covered by tests, 
// like *Code Contract* assertions and *Debug.Assert(…)* assertions.
//
// But if you wish to run this code query,
// you'll need to consider test assemblies in your list of 
// application assemblies analyzed by NDepend.
//</Description>]]></Query>
    </Group>
    <Group Name="Statistics" Active="False" ShownInReport="False">
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used files </Name>
(from f in Application.Files orderby f.FilesUsingMe.Count() descending
 select new { f, f.FilesUsingMe }).Take(50)

]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used methods (Rank)</Name>
(from m in Application.Methods orderby m.Rank descending
 select new { m, m.Rank }).Take(50)

// MethodRank values are computed by applying 
// the Google PageRank  algorithm on the graph of 
// methods' dependencies. Methods with high Rank 
// are the most used ones. See the definition of 
// the MethodRank metric here:
// http://www.cppdepend.com/Metrics.aspx#MethodRank]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used types (#TypesUsingMe )</Name>
(from t in Types orderby t.NbTypesUsingMe descending
 select new { t, t.TypesUsingMe }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used methods (#MethodsCallingMe )</Name>
(from m in Methods orderby m.NbMethodsCallingMe descending
 select new { m, m.MethodsCallingMe }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods that use many other methods (#MethodsCalled )</Name>
(from m in Application.Methods orderby m.NbMethodsCalled descending
 select new { m, m.MethodsCalled }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level Projects (Level)</Name>
from a in Application.Projects orderby a.Level descending
select new { a, a.Level }

// Classify Projects by their Level values.
// See the definition of the projectLevel metric here:
// http://www.cppdepend.com/Metrics.aspx#Level]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level methods (Level)</Name>
from m in Application.Methods orderby m.Level descending
select new { m, m.Level }

// Classify methods by their Level values.
// See the definition of the MethodLevel metric here:
// http://www.cppdepend.com/Metrics.aspx#Level]]></Query>
    </Group>
    <Group Name="Samples of Custom rules" Active="False" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the project P1 is not using the project P2</Name>
warnif count > 0 from a in Application.Projects where 
  a.IsUsing ("P2".AllowNoMatch().MatchProject()) &&
  (a.Name == @"P1")
select a
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the project P1 is only using the Projects P2 or P3</Name>
warnif count > 0 from a in Application.Projects where 
  ( !a.IsUsing ("P2".AllowNoMatch().MatchProject()) ||
    !a.IsUsing ("P3".AllowNoMatch().MatchProject()) ||
    a.ProjectsUsed.Count() != 2) // Must not be used more than 2 Projects 
&& 
  (a.Name == @"P1")
select new { a, a.ProjectsUsed }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that only 3 Projects are using Project P</Name>
warnif count != 3 from a in Application.Projects where 
  a.IsUsing ("P".AllowNoMatch().MatchProject())
select a
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all methods that call Foo.Fct1() also call Foo.Fct2(Int32)</Name>
warnif count > 0 from m in Application.Methods where 
   m.IsUsing ("Foo.Fct1()".AllowNoMatch()) &&
  !m.IsUsing ("Foo.Fct2(Int32)".AllowNoMatch())
select m
]]></Query>
      <Group Name="Custom Naming Conventions" Active="False" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all types that derive from Foo, has a name that ends up with Foo</Name>
warnif count > 0 from t in Application.Types where 
   t.DeriveFrom ("Foo".AllowNoMatch().MatchType()) &&
  !t.NameLike (@"Foo$")
select new { t, t.NbLinesOfCode }
]]></Query>
      </Group>
    </Group>
    <Group Name="Trend Metrics" Active="True" ShownInReport="False">
      <Group Name="Code Size" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code" Unit="LoC" />  
Application.Projects.Sum(a => a.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code (JustMyCode)" Unit="LoC" />
JustMyCode.Methods.Sum(m => m.NbLinesOfCode)

// JustMyCode is defined by code queries prefixed with 'notmycode' 
// in the group 'Defining JustMyCode'.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code (NotMyCode)" Unit="LoC" />
Application.Methods.Where(m => !JustMyCode.Contains(m))
                   .Sum(m => m.NbLinesOfCode)

// JustMyCode is defined by code queries prefixed with 'notmycode' 
// in the group 'Defining JustMyCode'.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code Added since the Baseline" Unit="LoC" />  
( from a in Application.Projects
  let nbLocAdded = a.IsPresentInBothBuilds() ? 
                   a.NbLinesOfCode - (int)a.OlderVersion().NbLinesOfCode :
                   a.NbLinesOfCode
  select nbLocAdded)
.Sum(loc => loc)

// A value is computed by this Trend Metric query
// only if a Baseline for Comparison is provided.
// See Project Properties > Analysis > Baseline for Comparison
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Source Files" Unit="Source Files" />
Application.Projects.SelectMany(
  a => a.SourceDecls.Select(sd => sd.SourceFile.FilePathString.ToLower()))
.Distinct()
.Count()

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Comments" Unit="Lines" />  
Application.Projects.Sum(a => a.NbLinesOfComment)

// So far comments are only extracted from C# source code.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Projects" Unit="Projects" />
Application.Projects.Count()

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Types" Unit="Types" />
Application.Types.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Classes" Unit="Types" />
Application.Types.Count(t => t.IsClass && !t.IsGeneratedByCompiler)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Structures" Unit="Types" />
Application.Types.Count(t => t.IsStructure)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Methods" Unit="Methods" />
Application.Methods.Count(m => !m.IsGeneratedByCompiler)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Fields" Unit="Fields" />
Application.Fields.Count(f => 
   !f.IsEnumValue && 
   !f.IsGeneratedByCompiler && 
   !f.ParentType.IsEnumeration)

]]></Query>
      </Group>
      <Group Name="Maximum and Average" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # Lines of Code for Methods (JustMyCode)" Unit="LoC" />
JustMyCode.Methods
          .Max(m => m.NbLinesOfCode)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the (JustMyCode) method with largest # Lines of Code
// JustMyCode.Methods.OrderByDescending(m => m.NbLinesOfCode).Take(1).Select(m => new {m, m.NbLinesOfCode})
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Lines of Code for Methods" Unit="LoC" />
Application.Methods.Where(m => m.NbLinesOfCode > 0)
                   .Average(m => m.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Lines of Code for Methods with at least 3 Lines of Code" Unit="LoC" />
Application.Methods.Where(m => m.NbLinesOfCode >= 3)
                   .Average(m => m.NbLinesOfCode)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # Lines of Code for Types (JustMyCode)" Unit="LoC" />
JustMyCode.Types
          .Max(t => t.NbLinesOfCode)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the (JustMyCode) type with largest # Lines of Code
// JustMyCode.Types.OrderByDescending(t => t.NbLinesOfCode).Take(1).Select(t => new {t, t.NbLinesOfCode})

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Lines of Code for Types" Unit="LoC" />
Application.Types.Where(t => t.NbLinesOfCode > 0)
                 .Average(t => t.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max Cyclomatic Complexity for Methods" Unit="Paths" />
Application.Methods
          .Max(m => m.CyclomaticComplexity)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the most complex method, according to Cyclomatic Complexity
// Application.Methods.OrderByDescending(m => m.CyclomaticComplexity).Take(1).Select(m => new {m, m.CyclomaticComplexity})
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max Nb Lines of code for Files" Unit="Paths" />
Application.Files
          .Max(f => f.NbLinesOfCode)
          .ToEnumerable().Sum(loc => loc)

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average Cyclomatic Complexity for Methods" Unit="Paths" />
Application.Methods.Where(m => m.NbLinesOfCode> 0)
                   .Average(m => m.CyclomaticComplexity)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average Nb Lines of code for Files" Unit="Paths" />
Application.Files.Where(f => f.NbLinesOfCode> 0)
                   .Average(f => f.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max Nesting Depth for Methods" Unit="Scopes" />
Application.Methods
          .Max(m => m.NestingDepth)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the method with highest NestingDepth.
// Application.Methods.OrderByDescending(m => m.NestingDepth).Take(1).Select(m => new {m, m.NestingDepth})
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average Nesting Depth for Methods" Unit="Scopes" />
Application.Methods.Average(m => m.NestingDepth)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # of Methods for Types" Unit="Methods" />
Application.Types
           .Max(t => t.NbMethods) 
           .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the (JustMyCode) type with largest # of Methods
// JustMyCode.Types.OrderByDescending(t => t.NbMethods).Take(1).Select(t => new {t, t.Methods})

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Methods for Types" Unit="Methods" />
Application.Types.Average(t => t.NbMethods)]]></Query>
      </Group>
      <Group Name="Third-Party Usage" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Projects Used" Unit="Projects" />
ThirdParty.Projects.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Types Used" Unit="Types" />
ThirdParty.Types.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Methods Used" Unit="Methods" />
ThirdParty.Methods.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Fields Used" Unit="Fields" />
ThirdParty.Fields.Count()]]></Query>
      </Group>
      <Group Name="Code Coverage" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Percentage Code Coverage" Unit="%" />
((float)Application.Projects.Sum(a => a.NbLinesOfCodeCovered) /
        Application.Projects.Sum(a => a.NbLinesOfCode)
 * 100f)
.ToEnumerable().Sum()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code Covered" Unit="LoC" />
Application.Projects.Sum(a => a.NbLinesOfCodeCovered)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code Not Covered" Unit="LoC" />
Application.Projects.Sum(a => a.NbLinesOfCodeNotCovered)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code in Types 100% Covered" Unit="LoC" />
Application.Types.Where(t => t.PercentageCoverage == 100)
           .Sum(t => t.NbLinesOfCodeCovered)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code in Methods 100% Covered" Unit="LoC" />
Application.Methods.Where(m => m.PercentageCoverage == 100)
           .Sum(m => m.NbLinesOfCodeCovered)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max C.R.A.P Score" />

(from m in JustMyCode.Methods

// Don't match too short methods
where m.NbLinesOfCode > 10

let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (CC * CC * uncov * uncov * uncov) + CC
where CRAP != null && CRAP > 30 select CRAP)
.Max(CRAP => CRAP)

//<Description>
// **Change Risk Analyzer and Predictor** (i.e. CRAP) is a code metric
// that helps in pinpointing overly complex and untested code.
// Is has been first defined here: 
// http://www.artima.com/weblogs/viewpost.jsp?thread=215899
//
// The Formula is:  **CRAP(m) = CC(m)^2 * (1 – cov(m)/100)^3 + CC(m)**
//
// • where *CC(m)* is the *cyclomatic complexity* of the method *m*
//
// • and *cov(m)* is the *percentage coverage* by tests of the method *m*
//
// Matched methods cumulates two highly *error prone* code smells:
//
// • A complex method, difficult to develop and maintain.
//
// • Non 100% covered code, difficult to refactor without any regression bug.
//
// The highest the CRAP score, the more painful to maintain and error prone is the method.
//
// An arbitrary threshold of 30 is fixed for this code rule as suggested by inventors.
//
// Notice that no amount of testing will keep methods with a Cyclomatic Complexity
// highest than 30, out of CRAP territory.
//
// Notice that CRAP score is not computed for too short methods
// with less than 10 lines of code.
//
// To list methods with highest C.R.A.P scores, please refer to the default rule:
//   *Test and Code Coverage* > *C.R.A.P method code metric*
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average C.R.A.P Score" />

(from m in JustMyCode.Methods

// Don't match too short methods
where m.NbLinesOfCode > 10

let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (CC * CC * uncov * uncov * uncov) + CC
where CRAP != null && CRAP > 30 select CRAP)
.Average(CRAP => CRAP)

//<Description>
// **Change Risk Analyzer and Predictor** (i.e. CRAP) is a code metric
// that helps in pinpointing overly complex and untested code.
// Is has been first defined here: 
// http://www.artima.com/weblogs/viewpost.jsp?thread=215899
//
// The Formula is:  **CRAP(m) = CC(m)^2 * (1 – cov(m)/100)^3 + CC(m)**
//
// • where *CC(m)* is the *cyclomatic complexity* of the method *m*
//
// • and *cov(m)* is the *percentage coverage* by tests of the method *m*
//
// Matched methods cumulates two highly *error prone* code smells:
//
// • A complex method, difficult to develop and maintain.
//
// • Non 100% covered code, difficult to refactor without any regression bug.
//
// The highest the CRAP score, the more painful to maintain and error prone is the method.
//
// An arbitrary threshold of 30 is fixed for this code rule as suggested by inventors.
//
// Notice that no amount of testing will keep methods with a Cyclomatic Complexity
// highest than 30, out of CRAP territory.
//
// Notice that CRAP score is not computed for too short methods
// with less than 10 lines of code.
//
// To list methods with highest C.R.A.P scores, please refer to the default rule:
//   *Test and Code Coverage* > *C.R.A.P method code metric*
//</Description>]]></Query>
      </Group>
    </Group>
    <Group Name="Defining JustMyCode" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Discard methods with a pattern name</Name>
notmycode from m in Methods where m.SimpleName.StartsWith("pattern to exclude")
select m

//<Description>
//The domain JustMyCode represents a facility of CQLinq to eliminate generated code elements from CQLinq query results.
//For example the following query will only match large methods that are not generated by a tool (like a UI designer):
//from m in JustMyCode.Methods where m.NbLinesOfCode > 30 select m
//The set of generated code elements is defined by CQLinq queries prefixed with the CQLinq keyword notmycode.
//For example the query below matches methods defined in source files whose name ends up with a pattern. These are file generated by some tools:
//notmycode from m in Methods where
//  m.SourceFileDeclAvailable && 
//  m.SourceDecl.SourceFile.FileName.ToLower().EndsWith(".designer.cs")
//  select m
//The CQLinq queries runner executes all notmycode queries before queries relying on JustMyCode, hence the domain JustMyCode is defined once for all. Obviously the CQLinq compiler emits an error if a notmycode query relies on the JustMyCode domain. 
//</Description>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Discard types with a pattern name</Name>
notmycode from t in Types where t.Name.StartsWith("pattern to exclude")
select t

//<Description>
//The domain JustMyCode represents a facility of CQLinq to eliminate generated code elements from CQLinq query results.
//For example the following query will only match large types that are not generated by a tool (like a UI designer):
//from m in JustMyCode.Types where t.NbLinesOfCode > 3000 select t
//The set of generated code elements is defined by CQLinq queries prefixed with the CQLinq keyword notmycode.
//For example the query below matches types defined in source files whose name ends up with a pattern. These are file generated by some tools:
//notmycode from t in Types where
//  t.SourceFileDeclAvailable && 
//  t.SourceDecl.SourceFile.FileName.ToLower().EndsWith("pattern to exclude")
//  select m
//The CQLinq queries runner executes all notmycode queries before queries relying on JustMyCode, hence the domain JustMyCode is defined once for all. Obviously the CQLinq compiler emits an error if a notmycode query relies on the JustMyCode domain. 
//</Description>


]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>JustMyCode code elements</Name>
from elem in JustMyCode.CodeElements
select new { 
  elem,
  loc = elem.IsCodeContainer ? elem.AsCodeContainer.NbLinesOfCode : null
}

//<Description>
// This code query enumerates all
// *projects*, *namespaces*, *types*, *methods* and *fields*
// in your application, that are considered as being your code.
//
// This means concretely that the *ICodeBaseView* **JustMyCode**
// only shows these code elements. This code base view is used by 
// many default code rule to avoid being warned on code elements 
// that you don't consider as your code - typically the code 
// elements generated by a tool.
//
// These code elements are the ones that are not matched 
// by any quere prefixed with  **notmycode**.
//</Description>]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>NotMyCode code elements</Name>
from elem in Application.CodeElements.Where(element => !JustMyCode.Contains(element))
select new { 
  elem,
  loc = elem.IsCodeContainer ? elem.AsCodeContainer.NbLinesOfCode : null
}

//<Description>
// This code query enumerates all
// *projects*, *namespaces*, *types*, *methods* and *fields*
// in your application, that are considered as not being your code.
//
// This means concretely that the *ICodeBaseView* **JustMyCode**
// hide these code elements. This code base view is used by 
// many default code rules to avoid being warned on code elements 
// that you don't consider as your code - typically the code 
// elements generated by a tool.
//
// These code elements are the ones matched by queries prefixed with 
// **notmycode**.
//</Description>]]></Query>
    </Group>
  </Queries></NDepend>